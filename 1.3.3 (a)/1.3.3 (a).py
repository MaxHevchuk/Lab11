# -*- coding: utf-8 -*-
# 1.3.3 а) Дан двійковий файл f, компоненти якого є цілими ненульовими числами, причому кількість від'ємних чисел
# дорівнює кількості додатних, а загальне число компонентів кратне 5. Використовуючи допоміжний файл h, переписати в
# порядку проходження компоненти файлу f в файл g - три додатних, три від'ємних, три додатних, три від'ємних і так далі.
# Гевчук Максим КН-А

from random import *
import struct


def main():
    def randomNumbers():
        """Функція для заповнення файлу f випадковими числами так, щоб к-сть від'ємних == к-сті додатніх"""
        with open("f.txt", mode="wb") as f:
            array = []
            for i in range(30):
                array.append(randint(1, 100))
                array.append(randint(-100, -1))
            # після наповнення списку різними числами вони "перемішуються"
            shuffle(array)
            # потім "пакується" та записується у двійковий файл f
            f.write(struct.pack("60i", *array))

    randomNumbers()

    with open("f.txt", mode="rb") as file_f:
        with open("g.txt", mode="w") as file_g:
            with open("h.txt", mode="w") as file_h:
                # із файлу f читаються двійкові дані, "розпаковуються" та додаються у файл h || тип даних str
                try:
                    file_h.write(' '.join(map(str, struct.unpack("60i", file_f.readline()))))
                except struct.error:
                    main()
            with open("h.txt", mode="r") as file_h:
                # потім ці дані читаються з f та створюється список із тих чисел || тип даних int
                numbers = list(map(int, file_h.readline().split()))
                # id_ - індекс елементу, n - для підрахунку 3-ох чисел в ряд, len_num - для підрахунку к-сті всіх елементів
                id_, n, len_num = 0, 0, 0
                # ключ чи число від'ємне, чи додатнє
                minus = True
                # список, у який будуть додаватись елементи у заданому порядку
                arr = []
                while True:
                    # якщо число < 0, ключ буде для від'ємних чисел та n < 3
                    if (numbers[id_] < 0) and minus and (n < 3):
                        # то число буде додане до списку || тип даних str
                        arr.append(str(numbers[id_]))
                    # якщо воно >, то  0, ключ для додатніх та n < 3
                    elif (numbers[id_] > 0) and (not minus) and (n < 3):
                        # то воно буде додане до списку || тип даних str
                        arr.append(str(numbers[id_]))
                    else:
                        # якщо буде випадок, наприклад, коли цикл зупиниться на від'ємному, а ключ показувати на додатнє, то
                        # воно пропускається
                        id_ += 1
                        continue
                    # якщо число додане до списку, то воно видаляється із попереднього
                    numbers.pop(id_)
                    id_ = 0
                    n += 1
                    len_num += 1

                    # коли 3 числа одного знаку будуть стояти разом, то ключ перемикається на протилежний знак
                    if n == 3:
                        n = 0
                        minus = not minus

                    # коли цикл перебере всі елементи, то програма вийде із нього
                    if len_num == 60:
                        break
            # числа склеються з роздількиком ", " (кома пробіл)
            # та запишуться у файл g
            file_g.write(', '.join(arr))


if __name__ == '__main__':
    main()
